# 6장 브랜치

## 6.1 브랜치의 정의
- Branch : 가지
- 줄기 하나로부터 뻗어 나온 갈림길
- 기존의 저장공간으로부터 또다른 저장공간이 파생적으로 생성됨

### 6.1.1 브랜치를 사용해야 하는 이유
- 새로운 기능을 추가하거나, 많은 변경이 예상 될때 기존의 작업 폴더를 통째로 복사해서 작업
- 유지 측면에서 비효율적인 방식

### 6.1.2 깃의 브랜치
- 가상 폴더 : 실제로 복사를 하지 않아 물리적으로는 파일 하나만 있는 것으로 보임
-> 빠르고 유연한 공간 이동이 가능

- 독립적 동작 : 기존 원본 코드와 별개로 개발 작업을 브랜치별로 수행할 수 있고, 병합 또한 명령어를 통해 수행할 수 있음.

- 빠른 동작 : Blob 개념을 도입해 내부를 구조화하여, 브랜치 전환이 빠름.(Like Pointer)

- 브랜치 생성은 커밋을 생성하여 할당함.

## 6.2 기본 브랜치
- Git은 기본적으로 MASTER 브랜치를 가지고 있고, 각 브랜치는 HEAD 포인터를 가지고 있음.

### 6.2.1 MASTER 브랜치
- 폴더를 생성 후 git이 추적할 수 있도록 git init을 하면, 최초로 MASTER(MAIN) 브랜치가 생성됨.

### 6.2.2 브랜치 목록 확인
- 커밋과 이력은 브랜치에 기록되므로, 최소 1개 이상의 브랜치가 필요하며 기본 브랜치로 MASTER(MAIN)이 생성되며, git status 명령어를 통해 현재 브랜치를 확인할 수 있음.
- 브랜치의 목록은 git branch 명렁어를 통해 확인할 수 있음.

## 6.3 브랜치의 생성
- 브랜치는 가상의 작업 폴더이므로 물리적으로는 존재하지 않음.
- 브랜치를 생성하기 위해서는 기준이 되는 브랜치 혹은 커밋이 존재해야 함.
- 브랜치란 특정 커밋으로부터 시작되는 새로운 저장공간이므로, 브랜치 자체는 특정 커밋의 SHA1 해시키를 통해서도 생성할 수 있음.
- 브랜치를 생성만 하면, 해당 커밋을 가리키는 HEAD 포인터만 있는 브랜치가 생성됨.
- 브랜치의 실질적인 생성은, 브랜치 이동을 통해 새로운 커밋이 이루어졌을때 새로운 가지가 뻗어나가기 시작함.

### 6.3.1 사용자 브랜치 생성
- 또 하나의 개발 분기점을 의미
- 생성 개수의 제한은 없음
- git branch branch_name COMMIT_ID

-> COMMIT_ID를 입력하는 경우 해당 SHA1을 가지는 커밋을 시작위치로 HEAD 포인터를 가리키게 되며
-> COMMIT_ID가 없는 경우에는 현재 브랜치의 HEAD를 기준으로 생성됨.

### 6.3.2 브랜치 이름
- 알기 쉬운 이름으로 하는 것이 좋다.
- git flow에서 정의된 이름을 적용해도 좋다.

- `-` 기호로 시작 불가
- .로 시작 불가
- 연속적인 -- 포함 불가 등
- 중복된 네이밍 불가

### 6.3.3 소스트리 브랜치
- 명령어를 입력하지 않고, GUI를 활용해서 생성할 수 있다.
- SHELL에서는 현재 브랜치를 (*)로, 소스트리에서는 (o)로 표기된다.

## 6.4 브랜치 확인

### 6.4.2 브랜치 해시
- 브랜치는 특정 커밋의 SHA1을 가리키는 포인터
- git rev-parse branch_name

### 6.4.3 브랜치 상세 조회
- git branch -v 
- 브랜치 이름,커밋 ID, 커밋 메세지까지 조회 가능함.

## 6.5 브랜치 이동
- 브랜치 생성은 단순히 생성만 할 뿐, 해당 브랜치로 이동하지 않음

### 6.5.1 Checkout
- 현재 머무르고 있는 브랜치에서 새로운 브랜치로 이동할 때 사용하는 명령어
- git checkout branch_name
- 깃은 하나의 워킹 디렉토리만 가지고 있기 때문에, 이동전의 브랜치에서 작업은 저장하여 클린한 상태여야함.

### 6.5.2 브랜치 이동 원리
- HEAD : 변경된 브랜치의 마지막 최신 커밋을 가리킴.
- 브랜치 이동시 HEAD 포인터도 변경됨.
- 브랜치 이동전 워킹 디렉터리의 정리가 필요함.

### 6.5.3 소스트리에서 브랜치 이동
- GUI를 통해 간단하게 체크아웃 할 수 있음.

### 6.5.4 이전 브랜치
- 브랜치 이동시에 git checkout branch_name 을 통해 특정 브랜치를 지정
- 직전에 작업했던 브랜치로 이동시에는 git branch - 를 사용함.

### 6.5.5 워킹 디렉토리 정리
- 깃은 하나의 워킹 디렉터리를 가지기 때문에 브랜치 변경시 워킹 디렉터리도 변경됨
- 따라서, 브랜치 변경시 직전에 작업하고 있던 내용에 대해 워킹 디렉터리 정리가 필요함.

## 6.6 브랜치 공간
- 현재까지 작업한 로그 기록 확인하기
git log --graph --all
### --more 옵션으로 출력될 로그의 수를 지정할 수 있다.

- 브랜치가 변경되면 워킹 디렉토리도 함께 변경된다.

## 6.7 HEAD 포인터
- 마지막 커밋을 가리키는 포인터
- 매번 마지막 커밋을 찾는 부하를 방지함.

- 브랜치가 변경되면 HEAD 포인터도 함께 변경된다.
- 각 브랜치의 HEAD에 아이콘이 표시됨(소스트리)

- HEAD를 기준으로 상대적인 위치의 커밋을 찾을 수 있음(~,^ 사용함)

### 원격 저장소와 로컬 저장소의 HEAD 포인터의 차이를 나타내는 방법
- AHEAD, BHEAD : 기준은 원격 저장소의 브랜치로 함
- AHEAD : 로컬이 원격보다 앞서감.
- BHEAD : 로컬이 원격보다 뒤쳐짐.

## 6.8 생성과 이동을 동시에
- git checkout -b branch_name
- git switch -c branch_name
###  브랜치는 특정 커밋을 가리키는 별명과도 같기 때문에 CHECKOUT시 해시키를 사용할 수도 있다.
###  브랜치 이동을 HEAD포인터를 기준으로 상대적으로 할 수도 있다.
- git checkout -
- git switch -
### 직전의 브랜치로 이동하는 방법

## 6.9 원격 브랜치
- git remote add origin url

### 6.9.1 리모트 브랜치
- 원격저장소의 브랜치를 가리키는 포인터 
- 트래킹 브랜치라고도 부름

### 6.9.4 브랜치 업로드하기
- git push -u origin branch_name
#### 로컬브랜치를 푸시하면 원격저장소는 로컬 저장소의 브랜치와 동일한 이름으로 생성된다.

### 6.9.5 이름이 다른 브랜치
- git push origin branch_name:alias_name
#### 로컬의 branch_name 이 원격에서 alias_name 으로 인식된다.

### 6.9.6 업스트림 브랜치
- git clone url
#### master 브랜치만 가지고 오지만, 목록 확인은 가능하다.
- git branch -r
- git branch -a
- git branch -vv

### 새로운 트래킹 브랜치 로컬에 생성하기
- git checkout --track origin/branch_name

- git checkout -b new_name origin/branch_name
#### 원격의 branch_name을 로컬의 new_name 브랜치로 연결

- git push --set-upstream origin master
#### 현재 브랜치를 원격 저장소의 master와 연결

## 6.11 브랜치 삭제
- 현재 머무르고 있는 브랜치는 삭제할 수 없다.
### git branch -d/-D branch_name
- -d : 현재 스테이지 상태가 clean-up인 경우
- -D : 강제 삭제

### git push origin --delete remote_branch_name